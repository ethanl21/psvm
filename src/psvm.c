#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

#include "quickjs-libc.h"
#include "psvm-js.h" // generated by qjsc at build

// pipes for IPC
int parent_to_child[2];
int child_to_parent[2];

// JS code
// setupSim is from src/inline.js copied manually below
char *const createSim = "globalThis.SimulatorInstance = new psvm.ShowdownSimulator();";
char *const setupSim = "import * as os from \"os\";\r\n\r\nvar inBuf = new Uint8Array(2048);\r\nvar decoder = new psvm.TextEncoding.TextDecoder(\"utf-8\");\r\n\r\nos.setReadHandler(host.readFd, () => {\r\n  var bytes = os.read(host.readFd, inBuf.buffer, 0, 2048);\r\n  var msg = decoder.decode(inBuf);\r\n\r\n  var lines = msg.split(\"\\0\");\r\n  lines.forEach((line) => {\r\n    line = line.trim();\r\n    line += \"\\n\";\r\n  });\r\n\r\n  lines = lines.filter(function (entry) {\r\n    return entry.trim() != \"\";\r\n  });\r\n\r\n  (async function loop() {\r\n    for (let i = 0; i < lines.length; i++) {\r\n      if (lines[i].startsWith(\">\")) {\r\n         SimulatorInstance.writeToOmniscient(lines[i]);\r\n      }\r\n    }\r\n  })();\r\n});\r\n\r\nfunction waitForEmptyArray(arr) {\r\n  return new Promise((resolve) => {\r\n    const checkEmpty = () => {\r\n      if (arr.length === 0) {\r\n        resolve(); // Resolve the Promise when the array is empty\r\n      } else {\r\n        setTimeout(checkEmpty, 100); // Check again after a delay\r\n      }\r\n    };\r\n\r\n    checkEmpty(); // Start checking immediately\r\n  });\r\n}\r\n\r\nos.setWriteHandler(host.writeFd, () => {\r\n  if (SimulatorInstance.output.length > 0) {\r\n    const encoder = new psvm.TextEncoding.TextEncoder();\r\n\r\n    let line = SimulatorInstance.output.shift();\r\n    let msg = encoder.encode(line + \"\\0\");\r\n\r\n    let bytes = os.write(host.writeFd, msg.buffer, 0, line.length + 1);\r\n\r\n    if (line.startsWith(\"|win\") || line.startsWith(\"|tie\")) {\r\n      // wait for the output buffer to empty\r\n      waitForEmptyArray(SimulatorInstance.output).then(() => {\r\n        os.setReadHandler(host.readFd, null);\r\n        os.setWriteHandler(host.writeFd, null);\r\n      });\r\n    }\r\n  }\r\n});";

// Demo lines to insert into sim
const char *const inputLines[] = {
    ">start {\"formatid\":\"gen9customgame\"}",
    ">player p1 {\"name\":\"Bot 1\",\"team\":\"Samurott||AssaultVest|Torrent|knockoff,flipturn,grassknot,hydropump||85,85,85,85,85,85||||88|,,,,,Dark]Azumarill||SitrusBerry|HugePower|liquidation,aquajet,playrough,bellydrum||85,85,85,85,85,85||||82|,,,,,Water]Meowscarada||ChoiceBand|Protean|knockoff,playrough,flowertrick,uturn||85,85,85,85,85,85||||78|,,,,,Grass]Iron Valiant||LifeOrb|QuarkDrive|swordsdance,spiritbreak,knockoff,closecombat||85,85,85,85,85,85|N|||79|,,,,,Fighting]Clodsire||Leftovers|Unaware|recover,curse,earthquake,gunkshot||85,85,85,85,85,85||||81|,,,,,Ground]Ampharos||ChoiceSpecs|Static|focusblast,voltswitch,thunderbolt,dazzlinggleam||85,,85,85,85,85||,0,,,,||88|,,,,,Fairy\"}",
    ">player p2 {\"name\":\"Bot 2\",\"team\":\"Jolteon||Leftovers|VoltAbsorb|substitute,terablast,calmmind,thunderbolt||85,,85,85,85,85||,0,,,,||84|,,,,,Ice]Greedent||SitrusBerry|CheekPouch|bodyslam,earthquake,psychicfangs,swordsdance||85,85,85,85,85,85||||87|,,,,,Psychic]Lurantis||Leftovers|Contrary|knockoff,leafstorm,synthesis,superpower||85,85,85,85,85,85||||91|,,,,,Fighting]Polteageist||WhiteHerb|CursedBody|shadowball,storedpower,gigadrain,shellsmash||85,,85,85,85,85|N|,0,,,,||79|,,,,,Psychic]Gurdurr||Eviolite|Guts|drainpunch,knockoff,machpunch,bulkup||85,85,85,85,85,85||||85|,,,,,Steel]Glastrier||ChoiceBand|ChillingNeigh|iciclecrash,highhorsepower,closecombat,heavyslam||81,85,85,85,85,85|N|||86|,,,,,Fighting\"}",
    ">p1 default",
    ">p2 default",
    ">p1 default",
    ">p2 default",
    "aaa", // demo ignored input
    "aaa",
    "aaa",
    "aaa",
    ">forcetie"};
const int INPUT_LINE_COUNT = 12;

/// @brief Constructs a new JSContext. os can be imported and the JS bundle is added to the global scope
/// @param rt a JSRuntime
/// @return JSContext inside rt with modules initialized
static JSContext *JS_NewCustomContext(JSRuntime *rt)
{
  JSContext *ctx = JS_NewContextRaw(rt);
  if (!ctx)
    return NULL;
  JS_AddIntrinsicBaseObjects(ctx);
  JS_AddIntrinsicDate(ctx);
  JS_AddIntrinsicEval(ctx);
  JS_AddIntrinsicStringNormalize(ctx);
  JS_AddIntrinsicRegExp(ctx);
  JS_AddIntrinsicJSON(ctx);
  JS_AddIntrinsicProxy(ctx);
  JS_AddIntrinsicMapSet(ctx);
  JS_AddIntrinsicTypedArrays(ctx);
  JS_AddIntrinsicPromise(ctx);
  JS_AddIntrinsicBigInt(ctx);
  js_init_module_os(ctx, "os");

  // Add compiled JS bundle to global namespace
  js_std_eval_binary(ctx, qjsc_psvm, qjsc_psvm_size, 0);
  js_std_eval_binary(ctx, qjsc_globalize, qjsc_globalize_size, 0);

  // Expose pipes to JS context
  JSValue global_obj = JS_GetGlobalObject(ctx);
  JSValue host = JS_NewObject(ctx);
  JS_SetPropertyStr(ctx, global_obj, "host", host);
  JS_SetPropertyStr(ctx, host, "readFd", JS_NewInt32(ctx, parent_to_child[0]));
  JS_SetPropertyStr(ctx, host, "writeFd", JS_NewInt32(ctx, child_to_parent[1]));

  JS_FreeValue(ctx, global_obj);
  return ctx;
}

void parent_function(void)
{
  // send all the lines to the child via pipe
  for (int i = 0; i < INPUT_LINE_COUNT; i++)
  {
    write(parent_to_child[1], inputLines[i], (strlen(inputLines[i]) + 1));
  }

  // there should be output in the output pipe now
  char buffer[1024];
  int loop = 1;
  while (loop)
  {
    ssize_t bytes_read = read(child_to_parent[0], buffer, 1024);

    if (bytes_read <= 0)
    {
      // break
      loop = 0;
    }
    else
    {
      // todo: do something with the output here
      printf("%s\n", buffer);
    }
  }
}

void child_function(int argc, char **argv)
{
  // QuickJS Runtime and Context
  JSRuntime *rt;
  JSContext *ctx;
  rt = JS_NewRuntime();
  js_std_init_handlers(rt);
  JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);
  ctx = JS_NewCustomContext(rt);
  js_std_add_helpers(ctx, argc, argv);

  // Create the simulator object
  JS_Eval(ctx, createSim, strlen(createSim), "<module>", JS_EVAL_TYPE_MODULE);

  // Handle input from the input pipe
  JS_Eval(ctx, setupSim, strlen(setupSim), "<module>", JS_EVAL_TYPE_MODULE);

  js_std_loop(ctx);
  JS_FreeContext(ctx);
  JS_FreeRuntime(rt);
}

int main(int argc, char **argv)
{
  // Create pipes
  if (pipe(parent_to_child) == -1 || pipe(child_to_parent) == -1)
  {
    perror("pipe");
    exit(EXIT_FAILURE);
  }

  // Create child process for simulator
  pid_t child_pid = fork();
  if (child_pid == -1)
  {
    perror("fork");
    exit(EXIT_FAILURE);
  }

  if (child_pid == 0)
  { // inside child
    // close unused pipe ends
    close(parent_to_child[1]);
    close(child_to_parent[0]);

    // run child fn (run the simulator)
    child_function(argc, argv);

    // clean up
    close(parent_to_child[0]);
    close(child_to_parent[1]);
  }
  else
  { // inside parent
    // close unused pipe ends
    close(parent_to_child[0]);
    close(child_to_parent[1]);

    // run parent fn (insert lines into the simulator and handle output)
    parent_function();

    // clean up
    close(parent_to_child[1]);
    close(child_to_parent[0]);
    wait(NULL);
  }

  return 0;
}